<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>new</title>
</head>

<body>
    <script>

        const isComplexDataType = obj => (
            ['object', 'function'].includes(typeof obj) && obj !== null
        )
        // new操作符做了这些事：
        //     它创建了一个全新的对象
        //     它会被执行[[Prototype]]（也就是__proto__）链接
        //     它使this指向新创建的对象
        //     通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上
        //     如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用将返回该对象引用

        const newNew = function () {
            // 创建新对象方法一
            const obj = new Object();
            const Constructor = [].shift.call(arguments);
            obj.__proto__ = Constructor.prototype;

            const ret = Constructor.apply(obj, arguments);
            return isComplexDataType(ret) ? ret : obj;
        }

        const newNew1 = (fn, ...rest) => {
            // 创建新对象方法二
            // const instance = Object.create(fn.prototype);

            // 创建新对象方法三
            const instance = {};instance.__proto__ = fn.prototype;

            const res = fn.apply(instance, rest);
            return isComplexDataType(res) ? res : instance
        }

        const A = function (a, b) {
            return function () {
                return a + b
            };
        }
        var obj = newNew(A, 1, 2);
        console.log('newNew', obj());
        var obj1 = newNew1(A, 3, 4);
        console.log('newNew1', obj1());
    </script>
</body>

</html>